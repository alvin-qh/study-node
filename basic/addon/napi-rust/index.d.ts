/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

/**
 * 定义常量, 并通过 `#[napi]` 属性标识, 向 Node 导出 Rust 常量
 *
 * 导出的函数相当于下面的 js 代码:
 *
 * ```js
 * export const HELLO: string
 * ```
 */
export const HELLO: string
/**
 * 定义函数, 并通过 `#[napi]` 属性标识, 向 Node 导出 Rust 函数
 *
 * 导出的函数相当于下面的 js 代码:
 *
 * ```js
 * export function helloWorld(): string {
 *   return HELLO;
 * }
 * ```
 */
export declare function helloWorld(): string
/**
 * 定义函数, 并通过 `#[napi]` 属性标识, 向 Node 导出 Rust 函数
 *
 * 导出的函数相当于如下的 js 代码:
 *
 * ```js
 * export function sum(a: number, b: number): number {
 *   return a + b;
 * }
 * ```
 */
export declare function sum(a: number, b: number): number
/**
 * 定义 `Gender` 枚举, 并通过 `#[napi(string_enum)]` 属性标识, 向 Node 导出值为字符串的枚举
 *
 * 导出的枚举相当于如下 js 代码:
 *
 * ```js
 * export const enum Gender {
 *   Male = 'Male',
 *   Female = 'Female'
 * }
 * ```
 */
export const enum Gender {
  Male = 'Male',
  Female = 'Female'
}
/**
 * 定义函数, 并通过 `#[napi]` 属性标识, 并向 Node 导出函数
 *
 * 导出的函数相当于如下 js 代码:
 *
 * ```js
 * export function createUser(no: string, name: string, gender: Gender): User
 * ```
 *
 * 函数可以返回 `User` 类型实例或 `napi::Result<User>` 类型枚举, 这两种返回值映射到 Node 函数时返回值都为 `User` 类型,
 * 区别在于:
 * - 如果函数返回了 `Ok(User)`, 则在 Node 中直接返回 `User` 类对象;
 * - 如果函数返回了 `Err(Error)`, 则在 Node 中会抛出异常;
 */
export declare function createUser(no: string, name: string, gender: Gender): User
/**
 * 定义函数, 并通过 `#[napi]` 属性标识, 并向 Node 导出函数
 *
 * 导出的函数相当于如下 js 代码:
 *
 * ```js
 * export function userToString(user: User): string
 * ```
 */
export declare function userToString(user: User): string
/**
 * 定义结构体, 并通过 `#[napi(constructor)]` 属性标识, 向 Node 导出 Rust 类, 并自动生成参数构造器
 *
 * 导出的函数相当于下面的 js 代码:
 *
 * ```js
 * export class DemoWithDefaultConstructor {
 *   name: string
 *   age: number
 *   gender: string
 *
 *   constructor(name: string, age: number, gender: string)
 * }
 * ```
 *
 * `#[napi(constructor)]` 属性标记中的 `constructor` 参数在 Node 中自动为类生成构造器, 该构造器的生成规则为:
 * - 结构体中所有修饰了 `pub` 的字段均会在构造器内部进行赋值;
 * - 构造器的参数为按照结构体字段顺序, 将所有修饰了 `pub` 字段对应生成为参数;
 */
export declare class DemoWithDefaultConstructor {
  name: string
  age: number
  gender: string
  constructor(name: string, age: number, gender: string)
  /**
   * 定义方法, 用于获取当前实例的 `json` 字符串
   *
   * 通过 `#[napi(getter)]` 属性标记, 将该方法生成为 Node 的 `get` 方法
   *
   * 导出的方法相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithDefaultConstructor {
   *   get json(): string
   *   ...
   * }
   * ```
   *
   * 该方法可以返回 `String` 类型实例或 `napi::Result<String>` 类型枚举, 这两种返回值映射到 Node 方法时返回值都为 `String` 类型,
   * 区别在于:
   * - 如果函数返回了 `Ok(String)`, 则在 Node 中直接返回 `String` 字符串对象;
   * - 如果函数返回了 `Err(Error)`, 则在 Node 中会抛出异常;
   */
  get json(): string
  /**
   * 定义方法, 用于为当前实例设置 `json` 字符串
   *
   * 通过 `#[napi(setter)]` 属性标记, 将该方法生成为 Node 的 `set` 方法
   *
   * 导出的方法相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithDefaultConstructor {
   *   set json(json: string): void
   *   ...
   * }
   * ```
   *
   * 该方法可以无返回值或返回 `napi::Result<()>` 类型枚举, 这两种返回值映射到 Node 方法时返回值都为 `void` 类型,
   * 区别在于:
   * - 如果函数返回了 `Ok(())`, 则在 Node 中表示无返回值;
   * - 如果函数返回了 `Err(Error)`, 则在 Node 中会抛出异常;
   */
  set json(json: string)
  /**
   * 定义方法, 用于改变 `DemoWithDefaultConstructor` 结构体实例的字段值
   *
   * 通过 `#[napi]` 属性标记, 将该方法生成为 Node 的 `change` 方法
   *
   * 导出的方法相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithDefaultConstructor {
   *   change(name: string, age: number, gender: string): void
   *   ...
   * }
   * ```
   */
  change(name: string, age: number, gender: string): void
  /**
   * 定义方法, 用于将 `DemoWithDefaultConstructor` 结构体实例转为字符串
   *
   * 通过 `#[napi]` 属性标记, 将该方法生成为 Node 的 `toString` 方法
   *
   * 导出的方法相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithDefaultConstructor {
   *   toString(): string
   *   ...
   * }
   * ```
   */
  toString(): string
}
/**
 * 定义结构体, 并通过 `#[napi(js_name = "DemoWithCustomConstructor")]` 属性标识, 向 Node 导出 Rust 类, 并且不会自动生成类构造器,
 * 其中的 `js_name = "DemoWithCustomConstructor"` 参数表示生成的 Node 类名称
 *
 * 需要在结构体的 `impl` 实现中手动添加构造器方法
 *
 * 导出的函数相当于下面的 js 代码:
 *
 * ```js
 * export class DemoWithCustomConstructor {
 *   name: string
 *   age: number
 *   gender: string
 * }
 * ```
 */
export declare class DemoWithCustomConstructor {
  name: string
  age: number
  gender: string
  /**
   * 定义生成结构体实例的方法, 并通过 `#[napi(constructor)]` 属性标识, 表示在 Node 中生成为类构造函数
   *
   * 导出的函数相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithCustomConstructor {
   *   ...
   *   constructor(name: string, age: number, gender: string)
   * }
   * ```
   *
   * 该方法的方法名可以任意定义, 但遵从 Rust 规范, 一般命名为 `new` 方法
   */
  constructor(name: string, age: number, gender: string)
}
/**
 * 定义结构体, 并通过 `#[napi(js_name = "DemoWithFactory")]` 属性标识, 向 Node 导出 Rust 类, 并自动生成参数构造器
 * 其中的 `js_name = "DemoWithFactory"` 参数表示生成的 Node 类名称
 *
 * 该结构体不会在映射为 Node 代码时产生构造器
 *
 * 导出的函数相当于下面的 js 代码:
 *
 * ```js
 * export class DemoWithFactory {
 *   name: string
 *   age: number
 *   gender: string
 * }
 * ```
 */
export declare class DemoWithFactory {
  name: string
  age: number
  gender: string
  /**
   * 为结构体定义方法, 用于构建结构体实例, 并通过 `#[napi(factory)]` 属性标识, 表示在 Node 中生成静态工厂方法
   *
   * 该方法参数不包含 `&self` 参数, 故而为一个 "静态" 函数, 生成 Node 函数时也为 "静态" 函数
   *
   * 导出的函数相当于下面的 js 代码:
   *
   * ```js
   * export class DemoWithCustomConstructor {
   *   ...
   *   static build(name: string, age: number, gender: string): DemoWithFactory
   * }
   * ```
   */
  static build(name: string, age: number, gender: string): DemoWithFactory
}
/**
 * 定义 `User` 结构体, 并通过 `#[napi(constructor)]` 属性标识, 并向 Node 导出类, 属性的 `constructor` 参数表示为 Node 自动生产参数构造器
 *
 * 导出的类相当于如下 js 代码:
 *
 * ```js
 * export declare class User {
 *   no: string
 *   name: string
 *   gender: Gender
 * }
 * ```
 */
export declare class User {
  no: string
  name: string
  gender: Gender
  constructor(no: string, name: string, gender: Gender)
}
